"""
Data loading and partitioning utilities for the malware FL demo.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Tuple

import numpy as np
import pandas as pd
from sklearn.model_selection import StratifiedKFold, train_test_split
from sklearn.preprocessing import StandardScaler


@dataclass
class DatasetPartition:
    train_x: np.ndarray
    train_y: np.ndarray
    val_x: np.ndarray
    val_y: np.ndarray


def _load_malmem_dataframe(csv_path: Path) -> pd.DataFrame:
    df = pd.read_csv(csv_path)
    if "Class" not in df.columns:
        raise ValueError("Expected 'Class' column in MalMem dataset")
    return df


def load_malmem(
    csv_path: str | Path = "Obfuscated-MalMem2022.csv",
) -> Tuple[np.ndarray, np.ndarray, StandardScaler]:
    """Load the MalMem dataset and return scaled features/labels."""
    df = _load_malmem_dataframe(Path(csv_path))

    features = df.drop(columns=["Class", "Category"], errors="ignore")
    labels = df["Class"].apply(lambda cls: 0 if str(cls).lower() == "benign" else 1)

    scaler = StandardScaler()
    x_scaled = scaler.fit_transform(features.values.astype(float))
    y = labels.to_numpy(dtype=np.int64)
    return x_scaled, y, scaler


def create_partitions(
    x: np.ndarray,
    y: np.ndarray,
    num_clients: int,
    val_ratio: float = 0.1,
    test_ratio: float = 0.1,
    seed: int = 42,
) -> Tuple[Dict[int, DatasetPartition], Tuple[np.ndarray, np.ndarray]]:
    """
    Split the dataset into client-specific partitions plus a shared test set.

    StratifiedKFold keeps class balance across clients, which is important for FL.
    """
    if num_clients < 1:
        raise ValueError("num_clients must be at least 1")

    x_train, x_test, y_train, y_test = train_test_split(
        x, y, test_size=test_ratio, random_state=seed, stratify=y
    )

    partitions: Dict[int, DatasetPartition] = {}
    if num_clients == 1:
        x_c_train, x_c_val, y_c_train, y_c_val = train_test_split(
            x_train,
            y_train,
            test_size=val_ratio,
            random_state=seed,
            stratify=y_train,
        )
        partitions[0] = DatasetPartition(
            train_x=x_c_train, train_y=y_c_train, val_x=x_c_val, val_y=y_c_val
        )
    else:
        skf = StratifiedKFold(n_splits=num_clients, shuffle=True, random_state=seed)
        for cid, (_, client_idx) in enumerate(skf.split(x_train, y_train)):
            x_client = x_train[client_idx]
            y_client = y_train[client_idx]

            x_c_train, x_c_val, y_c_train, y_c_val = train_test_split(
                x_client,
                y_client,
                test_size=val_ratio,
                random_state=seed,
                stratify=y_client,
            )
            partitions[cid] = DatasetPartition(
                train_x=x_c_train,
                train_y=y_c_train,
                val_x=x_c_val,
                val_y=y_c_val,
            )

    return partitions, (x_test, y_test)


def load_feature_names(csv_path: str | Path = "Obfuscated-MalMem2022.csv") -> list[str]:
    """Return ordered feature names from the MalMem CSV (excluding labels).

    Useful for explainability to map weights/attributions back to columns.
    """
    df = _load_malmem_dataframe(Path(csv_path))
    features = df.drop(columns=["Class", "Category"], errors="ignore")
    return list(features.columns)
